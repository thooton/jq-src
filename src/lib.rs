//! This crate aims to encapsulate the logic required for building `libjq`
//! from source (so that [jq-sys] doesn't have to know how to do this).
//!
//! The primary consumers of this crate are [jq-sys] (the generated bindings
//! to `libjq`), and indirectly [json-query] (a high-level wrapper for running
//! _jq programs_ over json strings).
//!
//! [jq-sys]: https://github.com/onelson/jq-sys
//! [json-query]: https://github.com/onelson/json-jquery

use std::env;
use std::path::{Path, PathBuf};

/// Information about the locations of files generated by `build()`.
///
/// After the jq sources have been compiled, the fields in this struct
/// represent where the various files ended up, and what sort of build was
/// done (ie, static or dynamic).
pub struct Artifacts {
    include_dir: PathBuf,
    lib_dir: PathBuf,
}

impl Artifacts {
    /// Prints cargo instructions for linking to the bundled `libjq`.
    pub fn print_cargo_metadata(&self) {
        println!("cargo:include={}", self.include_dir.display());
        println!("cargo:rustc-link-search=native={}", self.lib_dir.display());

        for lib in ["onig", "jq"] {
            println!("cargo:rustc-link-lib=static={}", lib);
        }
    }
    pub fn include_dir(&self) -> &Path {
        &self.include_dir
    }
    pub fn lib_dir(&self) -> &Path {
        &self.lib_dir
    }
}

/// Entry point for callers to run the build.
pub fn build() -> Result<Artifacts, ()> {
    let modules_dir = Path::new(env!("CARGO_MANIFEST_DIR")).join("modules");
    // todo: detect arch
    let my_dir = modules_dir.join("amd64");
    let lib_dir = my_dir.join("lib");
    let include_dir = my_dir.join("include");

    Ok(Artifacts {
        lib_dir,
        include_dir
    })
}